# coding=utf-8
# Autogenerated with SMOP version 0.23
# /usr/local/bin/smop -o combined.py __init__.py __init__.pyc parser.out parsetab.py Raytrace_model.m ssp_function.m UUV_time_delay_model.m
from __future__ import division
from collections import namedtuple
import sys

import numpy as np
from matplotlib import pylab as plt
from matplotlib import colors
from matplotlib import cm
from matplotlib import gridspec
from matplotlib.ticker import FixedLocator

import matplotlib2tikz


def Raytrace_Step(SSP, depth, ds, dtheta_count, graph, r_t, theta_min, theta_max, z_1, z_2, ax):
    theta = np.linspace(theta_min, theta_max, dtheta_count)
    z_end = np.empty_like(theta)
    tim = np.empty_like(theta)
    t = np.abs(theta_max - theta_min)
    if graph:
        norm = colors.LogNorm(vmin=0.5, vmax=360)
        print(t, norm(t))
        color = cm.Blues_r(norm(t))
    else:
        color = None

    candidate_ray = []
    # Now zoom in again on answer
    # Find candidate ray pairs
    for ii in range(max(theta.shape)):
        z_end[ii], tim[ii] = compute_ray(SSP, theta[ii], z_1, depth, r_t, z_2, ds, ax, color=color)  # nargout=2
        if (z_end[(ii - 1)] - z_2) * (z_end[ii] - z_2) < 0:
            # rays pass on opposite side of target
            candidate_ray.append(ii)
    # Now compare times of the candidate rays, and choose shortest
    try:
        m2 = np.argmin(tim[candidate_ray])  # nargout=2
    except ValueError as e:
        raise type(e), type(e)(e.message +
                               ' probably indicating that you haven\'t set the depth correctly %s' % depth), \
            sys.exc_info()[2]
    # m2 and (m2-1) are the indices of the candidate rays
    # candidate_ray(m2) is the best ray
    index = candidate_ray[m2]

    # Need to protect against i+-1 over/underflow
    index = max(1, index)
    index = min(dtheta_count - 2, index)
    guess_dist = 1490 * (tim[index])
    # print("With {} between {} and {}, best guess is {}: ".format(len(theta),theta_min,theta_max, guess_dist))
    return index, tim, z_end, theta[index - 1], theta[index + 1]


def Interpolate_Candidates(index, tim, z_2, z_end):
    z1 = z_end[index]
    z2 = z_end[(index - 1)]
    t1 = tim[index]
    t2 = tim[(index - 1)]
    # perform linear interpolation between candidate rays
    a = (z_2 - z1) / (z2 - z1)
    delay = a * t2 + (1 - a) * t1
    return delay


def Raytrace_model(uuv_pos, depth, SSP, graph, n_stages=3, dtheta_count=30, cone=45, ax=None):
    """uuv_pos = structre containing x,y,z positions of 2 uuvs
     depth = depth of water column
     SSP = name of sound speed profile
     graph: 0 = no graphs, 1 = plot ray paths 2 = plot and destroy
    :param dtheata_count: distance step in finite difference solution to ODE
    :param cone:  search cone angle
    """
    ds = 1
    # spearation between rays in initial coarse search (eventually zooms in to dtheta/400)
    # calculate distances
    dist = np.sqrt(
        (uuv_pos[0].x - uuv_pos[1].x) ** 2 + (uuv_pos[0].y - uuv_pos[1].y) ** 2 + (uuv_pos[0].z - uuv_pos[1].z) ** 2)
    r_t = np.sqrt((uuv_pos[0].x - uuv_pos[1].x) ** 2 + (uuv_pos[0].y - uuv_pos[1].y) ** 2)
    z_2 = uuv_pos[1].z
    z_1 = uuv_pos[0].z
    # Calculate angle between the two UUVs
    ang = (np.arctan((z_2 - z_1) / r_t) * 180) / np.pi
    # Degin the search angle (cone centred on the direct look)
    theta_min = np.max(np.array([- 89.99, ang - cone/2]).reshape(1, -1))
    theta_max = np.min(np.array([89.99, ang + cone/2]).reshape(1, -1))
    # Some error checking
    # if dist is very small
    if dist < np.dot(2, ds):
        c_av = np.dot(0.5, (ssp_function(z_2, SSP) + ssp_function(z_1, SSP)))
        delay = dist / c_av
        return delay, dist
        # go no further and return
    # if one uuv is right above the other do this
    if r_t == 0:
        # we just need the mean speed of sound
        c_av = 0
        z = np.linspace(z_2, z_1, 100)
        for count in range(100):
            c_av = c_av + ssp_function(z[(count - 1)], SSP)
        c_av /= 100
        delay = dist / c_av
        return delay, dist
        # go no further and return
    # do iterative ray tracing to find shortest eigenpath
    if graph:
        if ax is None:
            print "Using blank fig"
            f,ax = plt.subplots()

    for i in range(n_stages):
        index, tim, z_end, theta_min, theta_max = Raytrace_Step(SSP, depth, ds, dtheta_count, graph, r_t, theta_min,
                                                                theta_max, z_1, z_2, ax)

    delay = Interpolate_Candidates(index, tim, z_2, z_end)

    # this is the total time delay along the path
    if graph > 1:  # testing
        print "Dumping plots thanks to testing flag (graph=2)"
        plt.close('all')
    else:
        plt.show(block=False)
    return delay, dist


def compute_ray(SSP, theta_0, z_1, depth, r_t, z_2, dss, ax, color='-k'):
    ds = dss
    # pre allocate for greater speed
    #dimshape = int(np.round(np.floor((2 * r_t) / ds)*1.5)) #(was 1.5)
    dimshape = 1000
    r = np.empty(shape=dimshape, dtype='float64')
    z = np.empty(shape=dimshape, dtype='float64')
    t = np.empty(shape=dimshape, dtype='float64')
    r[0] = 0
    z[0] = z_1
    t[0] = 0
    theta = (theta_0 * np.pi) / 180
    c = ssp_function(z[0], SSP)
    xi = np.cos(theta) / c
    zeta = np.sin(theta) / c
    ax.plot(r[0], z[0], '*r')
    count = 0
    sign = 1
    while r[count] < r_t:
        count += 1
        z[count] = z[(count - 1)] + ds * c * zeta
        r[count] = r[(count - 1)] + ds * c * xi
        t[count] = t[(count - 1)] + ds / c
        # really ?
        c1 = ssp_function(z[count] - 0.5, SSP)
        c2 = ssp_function(z[count] + 0.5, SSP)
        c = (c1 + c2) / 2
        g = c2 - c1
        zeta -= ds * g / c / c
        if z[count] < 0:
            z[count] = - z[count]
            zeta = - zeta
            sign = - sign
        if z[count] > depth:
            z[count] = (2 * depth) - z[count]
            zeta = - zeta
            sign = - sign
        if r_t - r[count] < (ds * 2):
            ds = np.max(np.array([0.001, ds / 2]))

    ax.plot(r[0:count], z[0:count], color=color, lw=0.5)
    t_t = t[count]
    z_2 = z[count]
    return z_2, t_t


#
# Copyright (c) 2013 Plextek Limited, Great Chesterford, England.
# All Rights Reserved
#
# THIS FILE IS VERSION CONTROLLED USING SVN. DO NOT HAND EDIT THESE FIELDS
# ----------------------------------------------------------------------------
# $HeadURL$
# $Revision$
# $Author$
# $Date$
#
# File Description
# ================
#
# This script returns the sound speed for a given profile at a given
#    depth
#

SSPS = [
    'isovelocity',
    'n_squared',
    'linear_decreasing',
    'linear_increasing'
]

def ssp_function(z, profile):
    """outputs the velocity c at a particular depth z for a given profile
    """
    if 'isovelocity' == profile:
        c = 1490
    elif 'n_squared' == profile:
        c = 1550 / np.sqrt(1 + 2.4 * z / 1550.0)
    elif 'linear_decreasing' == profile:
        c = 1500 - 0.5 * z
    elif 'linear_increasing' == profile:
        c = 1480 + 0.5 * z
    else:
        raise NotImplementedError("Not a valid SSP")
    return c


#
#   Copyright (c) 2013 Plextek Limited, Great Chesterford, England.
#   All Rights Reserved
#
#   THIS FILE IS VERSION CONTROLLED USING SVN. DO NOT HAND EDIT THESE FIELDS
#   ----------------------------------------------------------------------------
#   $HeadURL$
#   $Revision$
#   $Author$
#   $Date$
#
#   File Description
#   ================
#
#    This script calculates the time taken along the shortest acoustic path
#    between two UUVs in a refractive underwater environment
#    It also estimates the distance between those two UUVs unp.sing different
#    assumptions
#
def Distance_Estimates(SSP, c, clock_error, delay, uuv_pos):
    # Estimated distance assuming SSP of 1490 m/s (how far uuv2 estmates uuv1 to
    # be away from it)
    guess_dist1 = 1490 * (delay + clock_error)
    # Estimated distance assuming SSP which is average of that local to UUV1 and
    # UUV2 repectively. (how far uuv2 estmates uuv1 to be away from it)
    c_av = 0.5 * (ssp_function(uuv_pos[0].z, SSP) + ssp_function(uuv_pos[1].z, SSP))
    guess_dist2 = (c_av * (delay + clock_error))
    # Estimated distance assuming SSP which is average of that of entire depth
    # |(how far uuv2 estmates uuv1 to be away from it)
    guess_dist3 = (np.average(c) * (delay + clock_error))
    # to estimate how far uuv1 thinks uuv2 is away from it, simply calculate clock_error = -clock_error)
    return guess_dist1, guess_dist2, guess_dist3


def UUV_time_delay(uuv1=(0, 0, 15), uuv2=(0, 500, 40), SSP='linear_increasing', graph=0, depth=30, clock_error=0,
                   dist_calc=False, tikz_plot=False, pdf_plot=False):
    """

    :param uuv1:
    :param uuv2:
    :param SSP:
    :param graph: bool or 2 for testing
    :param depth:
    :param clock_error:
    :param dist_calc:
    :return:
    """
    # initialise Sound speed profile
    z = np.linspace(0.1, depth, 100)
    ssp_getter = lambda zi: ssp_function(zi, SSP)
    c = map(ssp_getter, z)
    # plot graph of sound speed profile vs depth
    if graph:
        if pdf_plot is not None and 'figsize' in pdf_plot:
            fig = plt.figure(figsize=pdf_plot['figsize'])
        else:
            fig = plt.figure()
        gs = gridspec.GridSpec(1,5)
        gs.update(wspace=0.05, hspace=0.05)  # set the spacing between axes.

        sspax = plt.subplot(gs[:,4])
        sspax.plot(c, z)
        sspax.set_xlabel("$V_s (ms^{-1})$")
        sspax.set_xlim(1400,1560)
        sspax.invert_yaxis()
        sspax.xaxis.set_major_locator(FixedLocator([1400,1480,1560]))
        plt.setp(sspax.xaxis.get_majorticklabels(), rotation=30)

        tofax = plt.subplot(gs[:,0:4], sharey=sspax)
        plt.setp(sspax.get_yticklabels(),visible=False)
        tofax.set_ylabel("Depth $(m)$")
        tofax.set_xlabel("Distance $(m)$")

        fard = np.linalg.norm(uuv2[0:2])-np.linalg.norm(uuv1[0:2])
        tofax.plot([0], [uuv1[2]], 'or', zorder=10)
        tofax.plot([fard], [uuv2[2]], 'or', zorder=10)
        tofax.set_xlim(-0.05*fard, fard*1.05)
        print fard

    else:
        tofax = None

    # Position of uuv 1
    Pos = namedtuple('Pos', ['x', 'y', 'z'])
    uuv_pos = Pos(*uuv1), Pos(*uuv2)
    # position of uuv 2
    # Calculate the time true delay between the UUVs
    delay, true_dist = Raytrace_model(uuv_pos, depth, SSP, graph, ax=tofax)  # nargout=2
    response = (delay, true_dist)
    if dist_calc:
        guess_dist1, guess_dist2, guess_dist3 = Distance_Estimates(SSP, c, clock_error, delay, uuv_pos)
        response += guess_dist1, guess_dist2, guess_dist3
    if graph == 1:

        response += ((gs, sspax, tofax))

    if tikz_plot and all(map(lambda v:v in tikz_plot, ['filepath',])):
        tikz_plot['figure'] = fig
        print("Dumping: {}".format(tikz_plot))
        matplotlib2tikz.save(**tikz_plot)

    if pdf_plot and all(map(lambda v:v in pdf_plot, ['filepath',])):
        fig.savefig(pdf_plot['filepath']+'.pdf', format='pdf', bbox_inches='tight')


    return response

if __name__ == '__main__':
    print UUV_time_delay(dist_calc=True)
